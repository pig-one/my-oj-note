数组问题，移动0到数组后。
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n=nums.size();
        int zeronums = 0;
        for(int i = 0;i<n; i++)
        {
            zeronums += (nums[i] == 0);
        }
        vector<int > ans;
        for(int i = 0; i < n; i++){
            if (nums[i]!= 0){ans.push_back(nums[i]);}
        }
        while(zeronums--){
            ans.push_back(0);
        }
        for (int i=0;i<n;i++){
            nums[i] = ans[i];
        }
    }
};

hash表问题
happy number给定一个数字，判断每位平方相加，重复n次，判断能否十分最终的结果为1.
class Solution {
public:
    int oncesumsquire(int n){
        int sum = 0;
        while(n)
        {   
            int cash = n%10; 
            sum += cash * cash;
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        int slow=n;
        int fast=n;
        do
        {
            slow = oncesumsquire(slow);
            fast = oncesumsquire(fast);
            fast = oncesumsquire(fast);
        }while(slow != fast);
        if (slow == 1){
            return true;}
        else
            return false;
    }
};


链表问题：*****************************************************************
两个链表相加，给定两个链表,进位问题没看懂
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* current1 = l1;
        ListNode* current2 = l2;
        ListNode* res = NULL;
        int n1 = 0;
        int n2 = 0;
        while(current1)
        {
            current1 = current1->next;
            n1++;
        }
        while(current2)
        {
            current2 = current2->next;
            n2++;
        }
        current1 = l1;current2 = l2;
        while(n1>0&&n2>0)
        {
            int sum = 0;
            if(n1>=n2){
                sum += current1->val;
                current1 = current1->next;
                n1--;
            }
            if(n2>n1){
                sum += current2->val;
                current2 = current2->next;
                n2--;
            }
            res = AddToFront(sum,res);
        }
        current1 = res; res = NULL;
        int carry = 0;
        while(current1){
            current1->val += carry;
            carry = current1->val/10;
            //current1->value += carry;
            res = AddToFront(current1->val%10,res);
            current2 = current1;
            current1 = current1->next;
            delete current2;
        }
        if(carry == 1){
            res = AddToFront(1,res);
           
        } return res;
    }
    ListNode* AddToFront(int val,ListNode* res){
        ListNode* temp = new ListNode(val);
        temp->next = res;
        return temp;
    }
        
};


math问题：
把一个数组中的数字经过m次增加，使得数组中每个数字都相等，每次增加的值总和不得超过数组长度减1.纯粹的数学问题。
代码：
class Solution {
public:
    int minMoves(vector<int>& nums) {
        int n = nums.size();
        int sum = 0;
        int minNum = nums[0];
        for(int i=0;i<n;i++)
        {
            sum += nums[i];
            if (minNum > nums[i]){
                minNum = nums[i];
            }
        }
        return sum-minNum*n;
    }
};


Two pointers，双指针问题************************
三个数之和为零，返回二维数组
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ans;
        sort(nums.begin(),nums.end());
        //vector<vector<int>> ans;
        for(int i = 0 ;i < nums.size();i++){
            int target = -nums[i];
            int front = i+1;
            int rear = nums.size() - 1;
            //int sum = 0;

            while(front < rear)
            {
                int sum = nums[front] + nums[rear];
                if (sum < target){
                    front++;
                }
                else if(sum > target){
                    rear--;
                }
                else{
                    vector <int> triple(3,0);
                    triple[0] = nums[i];
                    triple[1] = nums[front];
                    triple[2] = nums[rear];
                    ans.push_back(triple);
                    while(front<rear && nums[front] == triple[1]) front++;
                    while(front<rear && nums[rear] == triple[2]) rear--;
                }
            }
            while(i+1<nums.size() && nums[i+1] == nums[i])
                i++;
        }
        return ans;
    }
};

String字符串问题，

二分检索问题
一行解决阶梯问题，其实本质上是数学问题。arranging coins
1+2+3+...+x = n
-> (1+x)x/2 = n
-> x^2+x = 2n
-> x^2+x+1/4 = 2n +1/4
-> (x+1/2)^2 = 2n +1/4
-> (x+0.5) = sqrt(2n+0.25)
-> x = -0.5 + sqrt(2n+0.25)

int arrangeCoins(int n) {
return floor(-0.5+sqrt((double)2*n+0.25));
}



分治法（divide and conquer）
beautiful arry(比较难想)
题目描述：
Saying that an array is beautiful,
there is no i < k < j,
such that A[k] * 2 = A[i] + A[j]
题解：
   vector<int> beautifulArray(int N) {
        vector<int> res = {1};
        while (res.size() < N) {
            vector<int> tmp;
            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);
            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);
            res = tmp;
        }
        return res;
    }
    
    
动态规划       Dynamic Programming
 2 keys keyboard
 质因数分解prime factorization
 思路：
 1.量化解空间，用c表示copy，p表示paste。则移动次序[cpp][cppp][cp].
 2.g1,g2,gn分别表示这些数组的长度
 3.‘A’的个数即为g1*g2*g3*...*gn个
 4.求最优：如果gi可分解，即可写为gi = p*q;那么就把这个数组拆分为两个数组（第一个数组有1个copy，p-1个paste。第二个数组有1个copy，q-1个paste）
 注意：这样分割步数最少，未分割前步数为pq，分割后步数为p+q。在p、q都大于等于2的时候，p+q <= pq 就等价于 1 <= (p-1)(q-1)
class Solution {
public:
    int minSteps(int n) {
        int stepNum = 0;
        int d = 2;
        while(n > 1){
            while(n%d == 0){
                stepNum += d;
                n /= d;
            }
            d += 1;
            
        }
        return stepNum;
    }
};




回溯backtracking








二维数组中的查找问题
总结3种方法可做此题：
1.依次遍历二维数组，查找是否存在。时间复杂度O(n^2);
2.因为是有序的，故首先想到二分查找，可对每一行进行二分查找。此时间复杂度为O(NlgN);
3.从二维数组的右上角开始，往回逼，此时间复杂度为O(n);
    class Solution {
public:
    bool Find(int target, vector<vector<int> > array) {
        //倒逼法解决
        int row = array.size();
        int column = array[0].size();
        int i = 0;
        int j = row - 1;
        while(i<column && j>=0){
            if(target > array[j][i]){
                i++;
            }
            else if(target < array[j][i]){
                j--;
            }
            else
                return true;
        }
        return false;
    }
};




替换数组中的空格为%20
两种方法：
1.开辟新数组，替换空格后，放入新数组。时间复杂度O(N),空间复杂度O(N)；
2.不额外占用空间，先计算替换后的数组长度，两个指针从后往前改变原数组内容。时间复杂度O(N)。
第二种源码：
class Solution {
public:
    void replaceSpace(char *str,int length) {
        //不开辟新数组，原数组从后往前遍历
        //1.先计算出空格数量，以求出替换后长度
        int BlankNum = 0;
        int OldBlankNum ;
        for (OldBlankNum = 0;str[OldBlankNum] != '\0';OldBlankNum++ ){
            if(str[OldBlankNum] == ' '){BlankNum++;}
        }
        int newLength = length + BlankNum*2;
        str[newLength] = '\0';
        int pointer1=length-1,pointer2 = newLength-1;
        while(pointer1>=0){
            if(str[pointer1] == ' '){
                str[pointer2--] = '0';
                str[pointer2--] = '2';
                str[pointer2--] = '%';
            }
            else
                str[pointer2--] = str[pointer1];
            pointer1--;
        }
    }
};




stack 
20. Valid Parentheses括号匹配，字符串是否合法问题
class Solution {
public:
    bool isValid(string s) {
        stack <char> st;
        for(char a : s){
            if(a == '(' || a=='[' || a=='{'){
                st.push(a);
            }else{
                if(st.empty()) return false;
                if(st.top() != '(' && a == ')') {
                     return false;
                }
                if(st.top() != '{' && a == '}') {
                     return false;
                }
                if(st.top() != '[' && a == ']') {
                     return false;
                }
                st.pop();
            }
        }
        //return st.empty();
        if(st.empty())
            return true;
        else
            return false;
    }
};




树
965. Univalued Binary Tree
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    //先序遍历来解
    bool PreOrderTraverse(TreeNode* root,int data){
        if(root){
            if(data != root->val){return false;}
            else if(!PreOrderTraverse(root->left,data)) return false;
            else if(!PreOrderTraverse(root->right,data)) return false;
        }
        return true;
    }
    bool isUnivalTree(TreeNode* root) {
        int data = root->val;
        return PreOrderTraverse(root,data);
        
    }
};





95. Unique Binary Search Trees II（不懂QaQ！！！！！！！！！！！！！！！）
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector<TreeNode*> generateTrees(int n) {
        vector<TreeNode*>tree;
        if(n==0){
            return tree;
        }
        dfs(1,n,tree);
        return tree;    
    }
private:
    void dfs(int start,int end,vector<TreeNode*>& tree){
        if(start>end){
            tree.push_back(NULL);
            return;
        }
        for(int i=start;i<=end;++i){
            vector<TreeNode*>left;
            vector<TreeNode*>right;
            dfs(start,i-1,left);
            dfs(i+1,end,right);
            for(int j=0;j<left.size();++j){
                for(int k=0;k<right.size();++k){
                    TreeNode* root = new TreeNode(i);
                    root->left = left[j];
                    root->right = right[k];
                    tree.push_back(root);
                }
            }
            
        }
    }
};
