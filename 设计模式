2019.5.12
UML类图：
    当一个类‘知道’另一个类时，关联。
    聚合：大雁和雁群。表示一种弱拥有关系，A对象可包含B对象，但B对象不是A对象的一部分。
    合成：鸟和它的翅膀，表示一种强的‘拥有关系’，体现了严格的部分与整体，部分与整体的生命周期一致。

1.简单工厂模式
    面向对象编程，曹操的诗，活字印刷，可维护，可扩展，可复用，灵活性。
    计算器：
        业务逻辑和界面逻辑分开，耦合度下降---------------封装
        把加减乘除写成运算类的子类------------------------------继承
        重写getResult()方法-----------------------------------多态
    简单工厂模式，即用一个单独的类来做一个创造实例的过程。根据输入的运算符号，工厂就实例化出合适的对象，然后通过多态，返回父类的方式得到计算结果。
    
    
2.策略模式
    面向对象编程，并不是类越多越好，类的划分是为了封装，分类的基础是抽象，具有相同属性和功能的对象的抽象集合就是类。
    商场收银软件：
        （----------------略）可以用简单工厂模式实现（现金收费工厂类CashFactorry，现金收费抽象类CashSuper，正常收费子类，打折收费子类，返利收费子类，客户端代码）
        策略模式和简单工厂模式实现：
            （CashContext,CashSuper,CashNormal,CashRebate,CashReturn,客户端代码），策略模式在CashContext中并不判断用哪个算法，但简单工厂模式需要。
            简单工厂模式需要让客户端认识两个类：现金收费工厂类CashFactorry，现金收费抽象类CashSuper
            但是策略模式与简单工厂结合，客户端只需要认识一个CashContext就可以，耦合度更低。
            
            
3.单一职责原则
    拍摄UFO,手机拍不清楚，有相机就好了。
    单一职责原则（SRP）:准确解释为：就一个类而言，应当仅有一个引起它变化的原因。
    方块游戏的设计，界面和逻辑分离，，如何确定一个类有过多的职责需要分离呢？？？
        答案是如果你可以想到多于一个的动机去改变一个类，那么这个类就有多于一个的职责，此时应该考虑职责分离！
        
        
4.开放--封闭原则
    一国两制，考研与求职
    开放--封闭原则：是说软件实体（类、模块、函数等）应该可以拓展，但是不可以修改。对于扩展是开放的，对于更改是封闭的。
    就如简单工厂模式中的计算器。面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码
    
    
    
5.依赖倒转原则
    帮MM修电脑。PC中CPU、内存、硬盘、显卡有一个共同点-------------------易插拔！对应面向对象中的强内聚，松耦合。
    依赖倒转原则：A.高层模块不应该依赖底层模块。两个都应该依赖抽象。（简单工厂模式中，简单工厂类依赖运算类）
                B.抽象不应该依赖细节，细节应该依赖抽象！（要针对接口编程，不要针对实现编程。。。cpu内部再复杂，对外提供的接口却是一致的）
    依赖倒转原则是面向对象的标志，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程。即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计。
    
6.里氏代换原则（LSP）
    准确解释为：子类型必须能够替换掉他们的父类型。
    
    
7.装饰模式
    准确的解释为：动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活。
    为什么？希望给每个对象而不是整个类添加一些功能。该模式提供了一个灵活的/可以替代继承的选择。
    小菜扮靓：
        我们需要做的就是把所需的功能按照正确的顺序串联起来进行控制。
        好处就是有效的把类中的核心职责和装饰功能区分开，并且可以去除相关类中的重复的装饰逻辑

8.代理模式
    准确解释为：为其他对象提供一种代理以控制对这个对象的访问
    为别人做嫁衣，吕秀才让燕小六向郭芙蓉求婚
        定义一个共用接口类，客户端关联接口，代理类关联真实类，并且都继承于接口


9.工厂方法模式
    复习回顾：
	简单工厂模式，简单工厂类依赖于抽象运算类，抽象运算类派生出加减乘除子类。
    	策略类，在（简单工厂类）中并不判断用哪个子类，需要到（客户端）中去判断。
    why not 简单工厂模式？
    	试想一下，再添加一个新算法的时候，先加具体的代码实现，再在简单工厂类中添加新的case判断语句，这就违背了“开放-封闭原则”。
    工厂方法模式：
    	准确的解释为：定义一个用于创造对象的接口类，让子类决定实例化哪个类，该模式使得实例化延迟到了其子类。
	当添加新的算法时，先在抽象运算类的基础上派生出新的运算实现类。然后，不需要在简单工厂类中加‘case’，取而代之的是接口类，只要根据新的算法类由接口类派生出相应的工厂子类即可。


10.原型模式
    写简历，写多份一样的简历，如何设计？
    准确的解释为：用原型实例指定创建对象的种类，并且通过copy这些原型创建新的对象。
    	return (prototype)this.MemberwiseClone();创建当前对象的浅表副本。。。创建一个新对象，然后将当前对象的非静态字段复制到该对象。
	好处：避免了多次new，执行多次构造函数，效率提高。并且隐藏了对象创建的细节！
    浅复制与深复制对比：
    	浅复制：被复制的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。
	深复制：把引用对象的变量指向复制过的新对象。
    深复制实现简历复制

11.


