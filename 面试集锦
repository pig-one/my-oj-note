面试集锦：


lenovo面试：
介绍自己？
问项目？


腾讯1面：
如何把c++融入c中？
C++有什么特征？
类的静态变量，函数的静态变量何时初始化？
STL用过吗？
指针和引用的区别？
python，文件名（内容）打印出来？
malloc和new？
openCV人脸识别，如何操作？彩色图-》灰度图-》csv，如何优化？

百度1面：
stl，链表(绝对值排序)2面，查找排序算法
linux查看进程的命令
堆和栈，堆内存栈内存
进程和线程
如何有效防范ddos攻击

小米1面：
http/udp协议，什么时候用udp什么时候用tcp？
多线程如何通信？
快速排序，二分搜索，哈希算法，2道编程题？
自我介绍？knn？
如何理解多态，虚函数？
const修饰函数，关键字？

天融信：
指针？
字符串,const？
Linux中设置断点，查看堆栈？
问到了内存，垃圾回收？









字节跳动模拟面试：
1.多态讲一下 
  c++中的多态主要是靠虚函数实现，多态是基于继承，层次结构，这意味着父类中的成员函数会根据调用函数对象类型的不同而不同。
  多态实现：定义一个基类的指针指向派生类的对象。
  如果不加virtual，子类调用函数仍将是基类中的成员函数。这种现象也成为静态链接，就是说函数调用在程序执行前其实就准备好了，也被称为早绑定。
  加上virtual后，在派生类要调用该成员函数时，会告诉编译器不要静态链接到该函数。成为动态链接，也成为晚绑定。
  纯虚函数，即在基类中不能给出实现，所以=0；

2.虚析构函数 
  析构函数被声明成虚函数，多态中，调用析构函数的时候只会析构基类的部分，派生类的析构函数并没有被调用，这样会造成内存泄漏。
  
3.进程与线程的区别
  如果把进程比作程序，那线程就是程序中的不同的功能块，可以这样理解。但是他们都是cpu工作的时间段的描述，只不过时间段长短而已。
  在资源方面，进程拥有资源，线程较为轻量级。进程有自己地址空间，一个进程崩了跟其他的进程没有关系，一个线程崩了，那这个进程也崩了。一个程序至少一个进程，一个进程至少一个线程
   同一进程的所有线程共享同一内存空间。
   
4.进程间通信有哪些 
   因为每个进程有自己的独立的内存空间，我的全局变量其他进程也看不到，所以进程间通信，必须通过内核，在内核中开辟一块缓冲区，A把数据从用户空间拷到缓冲区，B来读走，这就称为。。。
   我记得好像有8种：
   1.套接字通信，可用于不同机器间进程通信。
   2.共享内存，由一个进程创建一个共享内存，就是做个映射，把自己的内存空间映射到外面供其他进程访问。最快的一种，常与信号量等配合使用，实现同步等
   3.管道通信，匿名（亲缘关系），有名（也可非亲缘关系），高级（另一个程序当作一个新的进程在当前进程中启动，即把他变成我的子进程）
        半双工，1.父进程创建管道，得到两个文件描述符指向管道两端。2.fork出子进程，子进程就和父进程一样了。然后父进程关闭管道读，子进程关闭管道写。
   4.消息队列，其实就是一个存在在内核种的链表，这个链表存储了消息，并且他由消息队列标识符标识。
   5.信号量通信，他其实是一个锁，就是防止一个进程在访问共享内存时，其他进程也访问。他就是控制多个进程或线程对共享资源访问的一种机制。
   
5.线程间通信
  线程间通信主要用于线程同步，
  锁，互斥锁，读写锁之类。
  信号量机制，
  信号机制，
  
6.自旋锁是什么，怎么实现的
  其实跟互斥锁差不多，都是控制对共享资源的访问。互斥锁：一个线程占用了该资源，另一个线程则进入睡眠状态。自旋锁：一个线程占用资源后，两外的调用者不会睡眠，一直循环在看资源是否被释放。
  自旋锁：其实在循环检测资源的时候，他一直在占用CPU。如果别的线程占用很久的话，CPU使用率会非常高！！！
  优点：一直处于active，不用进行上下文切换，执行速度快。而互斥锁，阻塞在内核态，active在用户态，需要来回切换。
  
7.低地址到高地址说一下进程的虚拟地址空间
  当物理内存不够用的时候，拿出一部分的硬盘空间当作内存使用（即虚拟内存，放置非活跃性数据以及交换数据）。
  虚拟地址空间则是指每个进程拥有的私有内存大小。比如说4g的私有内存，能访问到2g，其他是系统保留。这2g也不是说立即分配，当进程用多少我给多少，虚拟内存和物理内存 只是映射关系，只有操作系统知道。
  程序代码和数据
  堆
  共享库
  栈
  内核虚拟存储器（顶部4分之一）
  
8.共享库的映射区是做什么的
  是这样的，同一个dll，可以被不同进程调用，内存中dll只有一份，不同的进程调用dll的函数，但数据放在自己的私有地址空间。如果想实现进程间通信，我可以把数据保存在dll的内存中，那么大家都可以访问
  
  
9.mmap映射到文件对象，设置为有效位无效，访问时再按需调页 
  mmap是一种内存映射文件的方法，他其实是把文件等映射到进程的内存空间，实现磁盘地址虚拟地址一一对应，这样可以用指针操作这段内存，系统对应操作磁盘文件，这就不用
  read，write等系统调用函数。并且内核对磁盘文件修改也会对进程修改，这就是先进程间通信。
  实现过程：
  1.进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域                （用户空间）void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
  2.调用内核空间的系统调用函数mmmap，实现文件物理地址到进程虚拟地址的映射     （内核空间）int mmap(struct file *filp, struct vm_area_struct *vma)
  3。进程发起对这片映射空间的访问，引发缺页异常（查询页表发现这段地址并不在物理页面上，因为之建立了地址映射，真正的硬盘数据并没要copy到内存），实现文件内容到物理内存的copy。
  内存读写，大规模数据传输
  
10.TCP了解多少 ，SYN攻击等
  3次握手，4次挥手。
  3次握手：
  1.（客户端）SYN=1，指明客户端打算连接的端口号，seq=x       SYN_SEND
  2.（服务器）SYN=1，ACK=1，seq=y，ACKNum=x+1              SYN_RCVD             （如果在服务器上发现由大量这种半链接，则为SYN攻击）
  3.（客户端）ACK=1，SYN=0，ACKNum=y+1                     ESTABLISHED
  4次挥手：
  1.（客户端）FIN=1，seq=x                                 FIN_WAIT_1
  2.（服务器）ACK=1，ACKnum=x+1                            客户端FIN_WAIT_2   服务器CLOSE_WAIT
  3.（服务器）FIN=1，seq=y                                 LAST_ACK
  4.（客户端）ACK=1，ACKnum=y+1                            TIME_WAIT     
  服务器收到后切换为CLOSED，客户端等待两个最大段生命周期后，没有收到来自服务器的ACK，则自己也关闭，进入CLOSED状态。
  防范SYN：
  缩短超时时间，增加最大半连接数，过滤网关防护，SYN cookies技术
  
11.什么时候会收到RST报文段
  TCP首部的RST比特是用于“复位”的，用来异常的关闭连接，的一般出现RST分节的状况会发生在：
  连接建立时（发送一个不存在的端口，端口未打开，请求超时，提前关闭，在一个已经关闭的socket上收到数据，异常终止连接等），在中间发送数据时（数据出错，并不是按照seq发送），连接关闭时（设置了套接字选项）
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
