c++多线程，创建多个线程
#include<map>
#include<string>
#include<thread>
#include<list>
#include<mutex>

using namespace std;
//县城入口函数
void myprint(){
	cout << "mypeint县城开始执行，编号=" << inum << endl;
	//....
	cout << "jieshu" << inum << endl;
	return;
}

int main(){
	//创建和等待多个线程
	vector <thread>mythreads;
	//创建10个县城，入口统一myprint
	for (int i = 0; i < 10; i++){
		mythreads.push_back(thread(mypeint, i));//创建开始执行的县城，并且开始执行

	}
	for (auto iter = mythread.begin(); iter != mythreads.end(); ++iter){
		iter->join();

	}
	cout << "i love you" << endl;
	return 0;
}



数据共享问题
1.只读的数据是安全稳定的，不需要什么特殊处理手段，直接读就行
2.有读有写，2线程写，8个线程读，无特别处理，成功需肯定崩溃。
    不奔溃处理：读的时候不能写，写的时候不能读。两个写线程不能同时写，8个线程不能同时读。
    写的动作分10小步；由于任务切换导致各种诡异事情发生（崩溃）；
案例：
数据共享，北京到深圳的动车，10个售票窗口卖票，1，2同事都要订99号座。




共享数据的保护案例代码：
假设开发一个网络游戏服务器，有2个自己创建的线程，1个线程收集玩家命令（用数字代表玩家命令），并写入一个队列，另一个线程从队列中取出玩家发送来的命令，解析，执行玩家动作；
vector，list：list频繁的按顺序插入和删除数据时效率高。vector容器对于随机的插入和删除数据效率高。
//用成员函数作为线程函数方法来写线程
class A{
public:
	//把收到的玩家命令插入到队列的线程
	void inMsgRecvQueue(){
		for (int i = 0; i < 100000; ++i){
			cout << "inMsgRecvQueue()执行，插入一个元素" << i << endl;
			msgRecvQueue.push_back(i);//假设数字i就是玩家发送过来的命令。
		}
	}
	//把数据从消息队列中取出的线程
	void outMsgRecvQueue(){
		for (int i = 0; i < 100000; ++i){
			if (!msgRecvQueue.empty()){
				//消息不为空
				int command = msgRecvQueue.front();//返回第一个元素，但不检查是否存在
				msgRecvQueue.pop_front();//移除第一个元素，但不返回
				//处理数据

			}
			else
			{
				cout << "outMsgRecvQueue()执行，但目前消息队列为空" << i << endl;
			}
		}
		cout << "end" << endl;
	}
private:
	std::list<int> msgRecvQueue;//共享数据
};
int main(){
	A myobja;
	std::thread myOutMsgObj(&A::outMsgRecvQueue, &myobja);//第二个参数是  引用,才能保障线程中用的是同一个对象
	std::thread myInMsgObj(&A::inMsgRecvQueue, &myobja);
	myInMsgObj.join();
	myOutMsgObj.join();
	return 0;
}
程序终止的原因，未加锁。共享数据只要不被破坏，程序就不汇报异常
代码化解决问题，引入c++解决多线程保护共享数据问题的第一个概念“互斥量”

