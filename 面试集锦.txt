面试集锦：

字节跳动：汉字转化成int类型的数字
hadoop中hdfs和hbase和hive之间有什么联系？
Hdfs作为hive和hbase最底层高可靠的支持。
Hive支持静态数据的动态查询 ，不允许修改数据，基于数据仓库，使用类sql语言，底层经过编译转为mapreduce程序，在hadoop上运行，数据存储在hdfs上。
Hdfs是GFS的一种实现，类似于FAT32，NTFS，是一种文件格式，是底层的，hive与hbase都存储在HDFS上。
Hbase是hadoop database，是一种分布式数据库，支持存储非结构化数据，基于列而不是基于行。他是google bigtable的实现。
三大对应：
Google bigtable利用GFS作为其文件存储系统，hbase利用hdfs作为其文件存储系统。
Google运行mapreduce来处理bigtable中的海量数据，hbase同样利用hadoop mapreduce来处理hbase中的海量数据
Pig和hive为hbase提供了高层语言支持，更侧重于数据的查询和分析，底层都是转化成mapreduce程序运行。


手机操作系统的标识？

图森未来

猿题库

京东：
1. 二叉树的序列化存储，根据前中序写树

2.给定一个函数，该函数可实现随机生成A,B,让你利用这个函数构造出随机生成5个数的函数
3.单链表排序，时间复杂度O(1)

头条
mapreduce
流式数据依次读入只能存放1000条数据的内存，等概率的取样取1000条







lenovo面试：
介绍自己？
问项目？


腾讯1面：
如何把c++融入c中？
C++有什么特征？
类的静态变量，函数的静态变量何时初始化？
STL用过吗？
指针和引用的区别？
python，文件名（内容）打印出来？
malloc和new？
openCV人脸识别，如何操作？彩色图-》灰度图-》csv，如何优化？

百度1面：
stl，链表(绝对值排序)2面，查找排序算法
linux查看进程的命令
堆和栈，堆内存栈内存
进程和线程
如何有效防范ddos攻击

小米1面：
http/udp协议，什么时候用udp什么时候用tcp？
多线程如何通信？
快速排序，二分搜索，哈希算法，2道编程题？
自我介绍？knn？
如何理解多态，虚函数？
const修饰函数，关键字？

天融信：
指针？
字符串,const？
Linux中设置断点，查看堆栈？
问到了内存，垃圾回收？


软件实现技术预答辩准备：
服务器为什么采用SRS？
1.追求更好的概念完整性和最简单实现的代码。
    

改进的软件开发瀑布模型
使用正式的错误跟踪系统和工作流报告错误
*计划使用客户反馈*团队参与和签署
并非所有错误都是被修复的 - 由Triage确定
大约一半的版本保留用于稳定
稳定性：测试通过，测试版，候选发布者

功能性前期测试不是那么深
*部署后可以修复
*进行更多生产测试（TiP）（AB比较）
*降低兼容性测试矩阵 - 仅测试一个环境
*更注重确保最大正常运行时间
*安全性
*压力/可扩展性
*网络容错
* H / W 容错
*记录/诊断辅助工具

单元测试框架
*也适用于非单元测试
*测试用例存储库（包括对手动测试的支持）






微软面试：
找出1到99缺失的一个数，两个数









字节跳动模拟面试：
1.多态讲一下 
  c++中的多态主要是靠虚函数实现，多态是基于继承，层次结构，这意味着父类中的成员函数会根据调用函数对象类型的不同而不同。
  多态实现：定义一个基类的指针指向派生类的对象。
  如果不加virtual，子类调用函数仍将是基类中的成员函数。这种现象也成为静态链接，就是说函数调用在程序执行前其实就准备好了，也被称为早绑定。
  加上virtual后，在派生类要调用该成员函数时，会告诉编译器不要静态链接到该函数。成为动态链接，也成为晚绑定。
  纯虚函数，即在基类中不能给出实现，所以=0；

2.虚析构函数 
  析构函数被声明成虚函数，多态中，调用析构函数的时候只会析构基类的部分，派生类的析构函数并没有被调用，这样会造成内存泄漏。
  构造函数里面可以调用虚函数吗？（可以调用，编译能通过。在基类构造函数调用虚函数、子类构造函数里调用虚函数分别分析，无法实现动态绑定） 
  
3.进程与线程的区别
  如果把进程比作程序，那线程就是程序中的不同的功能块，可以这样理解。但是他们都是cpu工作的时间段的描述，只不过时间段长短而已。
  在资源方面，进程拥有资源，线程较为轻量级。进程有自己地址空间，一个进程崩了跟其他的进程没有关系，一个线程崩了，那这个进程也崩了。一个程序至少一个进程，一个进程至少一个线程
   同一进程的所有线程共享同一内存空间。
   
4.进程间通信有哪些 
   因为每个进程有自己的独立的内存空间，我的全局变量其他进程也看不到，所以进程间通信，必须通过内核，在内核中开辟一块缓冲区，A把数据从用户空间拷到缓冲区，B来读走，这就称为。。。
   我记得好像有8种：
   1.套接字通信，可用于不同机器间进程通信。
   2.共享内存，由一个进程创建一个共享内存，就是做个映射，把自己的内存空间映射到外面供其他进程访问。最快的一种，常与信号量等配合使用，实现同步等
   3.管道通信，匿名（亲缘关系），有名（也可非亲缘关系），高级（另一个程序当作一个新的进程在当前进程中启动，即把他变成我的子进程）
        半双工，1.父进程创建管道，得到两个文件描述符指向管道两端。2.fork出子进程，子进程就和父进程一样了。然后父进程关闭管道读，子进程关闭管道写。
   4.消息队列，其实就是一个存在在内核种的链表，这个链表存储了消息，并且他由消息队列标识符标识。
   5.信号量通信，他其实是一个锁，就是防止一个进程在访问共享内存时，其他进程也访问。他就是控制多个进程或线程对共享资源访问的一种机制。
   
5.线程间通信
  线程间通信主要用于线程同步，
  锁，互斥锁，读写锁之类。
  信号量机制，
  信号机制，
  
6.自旋锁是什么，怎么实现的
  其实跟互斥锁差不多，都是控制对共享资源的访问。互斥锁：一个线程占用了该资源，另一个线程则进入睡眠状态。自旋锁：一个线程占用资源后，两外的调用者不会睡眠，一直循环在看资源是否被释放。
  自旋锁：其实在循环检测资源的时候，他一直在占用CPU。如果别的线程占用很久的话，CPU使用率会非常高！！！
  优点：一直处于active，不用进行上下文切换，执行速度快。而互斥锁，阻塞在内核态，active在用户态，需要来回切换。
  
7.低地址到高地址说一下进程的虚拟地址空间
  当物理内存不够用的时候，拿出一部分的硬盘空间当作内存使用（即虚拟内存，放置非活跃性数据以及交换数据）。
  虚拟地址空间则是指每个进程拥有的私有内存大小。比如说4g的私有内存，能访问到2g，其他是系统保留。这2g也不是说立即分配，当进程用多少我给多少，虚拟内存和物理内存 只是映射关系，只有操作系统知道。
  程序代码和数据
  堆
  共享库
  栈
  内核虚拟存储器（顶部4分之一）
  
8.共享库的映射区是做什么的
  是这样的，同一个dll，可以被不同进程调用，内存中dll只有一份，不同的进程调用dll的函数，但数据放在自己的私有地址空间。如果想实现进程间通信，我可以把数据保存在dll的内存中，那么大家都可以访问
  
  
9.mmap映射到文件对象，设置为有效位无效，访问时再按需调页 
  mmap是一种内存映射文件的方法，他其实是把文件等映射到进程的内存空间，实现磁盘地址虚拟地址一一对应，这样可以用指针操作这段内存，系统对应操作磁盘文件，这就不用
  read，write等系统调用函数。并且内核对磁盘文件修改也会对进程修改，这就是先进程间通信。
  实现过程：
  1.进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域                （用户空间）void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
  2.调用内核空间的系统调用函数mmmap，实现文件物理地址到进程虚拟地址的映射     （内核空间）int mmap(struct file *filp, struct vm_area_struct *vma)
  3。进程发起对这片映射空间的访问，引发缺页异常（查询页表发现这段地址并不在物理页面上，因为之建立了地址映射，真正的硬盘数据并没要copy到内存），实现文件内容到物理内存的copy。
  内存读写，大规模数据传输
  
10.TCP了解多少 ，SYN攻击等
  3次握手，4次挥手。
  3次握手：
  1.（客户端）SYN=1，指明客户端打算连接的端口号，seq=x       SYN_SEND
  2.（服务器）SYN=1，ACK=1，seq=y，ACKNum=x+1              SYN_RCVD             （如果在服务器上发现由大量这种半链接，则为SYN攻击）
  3.（客户端）ACK=1，SYN=0，ACKNum=y+1                     ESTABLISHED
  4次挥手：
  1.（客户端）FIN=1，seq=x                                 FIN_WAIT_1
  2.（服务器）ACK=1，ACKnum=x+1                            客户端FIN_WAIT_2   服务器CLOSE_WAIT
  3.（服务器）FIN=1，seq=y                                 LAST_ACK
  4.（客户端）ACK=1，ACKnum=y+1                            TIME_WAIT     
  服务器收到后切换为CLOSED，客户端等待两个最大段生命周期后，没有收到来自服务器的ACK，则自己也关闭，进入CLOSED状态。
  防范SYN：
  缩短超时时间，增加最大半连接数，过滤网关防护，SYN cookies技术
  
11.什么时候会收到RST报文段
  TCP首部的RST比特是用于“复位”的，用来异常的关闭连接，的一般出现RST分节的状况会发生在：
  连接建立时（发送一个不存在的端口，端口未打开，请求超时，提前关闭，在一个已经关闭的socket上收到数据，异常终止连接等），在中间发送数据时（数据出错，并不是按照seq发送），连接关闭时（设置了套接字选项）
  
12.服务器大量处于TIME_WAIT状态，可能的原因，造成什么影响，怎么解决?大量处于CLOSE_WAIT呢
   TIME_WAIT时客户端的状态吧，表示主动关闭！！！！他主要解决两个问题：1.如果最后一个ACK丢失，服务器要重新发送FIN。2.不允许残余在网络中的包被错误使用
   出现场景：
   在高并发短链接的TCP服务器上，服务器处理完后立刻主动正常关闭，此时大量的socket处于此状态，并发量持续很高，会出现连接不上的状况。
   短链接表示业务处理和传输数据的时间远小于TIME_WAIT时间。
   解决方案：
   1.发送RST而不是FIN，这样能越过TIME_WAIT状态，直接进入CLOSED状态   2.修改内核协议栈代码中的TIME_WAITED的超时间参数。缩短时间加快回收
   这可行但是不符合原则，我需要TIME_WAITED保证服务器程序的健壮性。需要尽量的处理TIME_WAITED过多：
   修改sysctl两个内核参数：net.ipv4.tcp_tw_reuse = 1     net.ipv4.tcp_tw_recycle = 1
   
   大量处于CLOSE_WAIT状态
   因为服务器端不执行socket的close操作，可能是I/O意外被阻塞，程序bug等。
   
 13.存储或队列
    一致性哈希算法，设计的目的是为了解决因特网中的热点问题。判断哈希算法好坏的四个指标：
    平衡性（金可莪能分散到所有缓冲区）/单调性（新的缓冲加入，不会映射到旧的上去）/分散性（避免相同内容被存储到不同缓冲）/负载
    分布式集群中，若采用常用的hash算法，一旦单点故障，很多数据无法找到，违反了单调性原则
    一致性hash算法设计原理（环形）：
    1.把数据通过一定的hash算法处理后映射到环上。
    2.将机器通过hash算法映射到环上。
    对于机器的增加与删除只需要更改一个object的映射即可。
    在一致性hash算法中，为了满足平衡性，引入虚拟节点的概念，它其实就是真是节点在hash空间的复制品，以hash值排列。
    
 14.i/o模型有哪些
    同步模型：
   直接等待： 阻塞I/O（IO执行的两个阶段都被阻塞，用户空间执行系统调用recvform，导致应用程序阻塞，啥也不干，知道数据准备好，并且从内核复制到用户进程，最后进程在处理）
    轮询：   非阻塞IO（非阻塞的recvform系统调用后，进程没有被阻塞，只是通过轮询的方式检查内核数据，知道内核数据准备好，在考到用户进程进行处理）
    select/epoll轮询：  多路复用IO（有两个特别的系统调用，select和poll，epoll）
              select/epoll优点：单个process可以同时处理多个（很重要）网络连接的IO，缺点：多个IO顺序变得不确定了，只适用于多个连接！！！
              与阻塞IO的不同，不是等全部数据都到来之后在处理，而是有了一部分数据便会调用用户进程来处理。
              与非阻塞IO不同，可以等待多个socket，能同时对多个IO端口进行监视，其中任意一个socket数据准备好，就返回可读，接着进程进行recvform系统调用，江数据从内核考到进程。
    从整个IO来看，他们都是顺序执行，因此可归为同步模型，都是进程主动等待并向内检查状态！！！！
    信号驱动式IO
    异步模型：
    异步IO（IO两个阶段都是非阻塞的，用户进程执行系统调用后，无论内核数据是否准备好，都返回给进程，然后用户进程该干啥干啥，socket数据准备好之后，内核直接复制数据给进程，然后向进程发送通知。）
    网络IO的本质是对socket的读取，而socket在linux中被称为流，IO可以理解为对流的操作。1.把数据copy到内核缓冲区2.从内核缓冲区copy到应用程序的地址空间。
    周末和女友逛街，饿了，吃饭需要排队，有上面几种方案：
  
15.正则表达式
    了解一点
    
16.有一个日志文件，里面每一行都有ip、time、context等信息，怎么查询某个ip有多少个 
    cat XXXX.log | awk '{print $NF-1}'(倒数第二列) | sort（排序） | uniq -c(排重) | sort -k 1 -n -r (对第一列按照纯数字逆序排列)| head -10(显示前10行)
    cat XXXX.log | grep -c IP
    cat XXXX.log | grep IP |wc -l
    
17.C++11里面auto有什么用，不给初始值可以吗 
    c++98中就有，不怎么常用，用于1.自动推断类型，类型名较长的时候2.返回值占位。必须初始化
    
18.volatile有什么用
    与优化相关，它就是告诉编译器我这个变量随时可能发生变化，，不要进行编译优化（将内存变量缓存到寄存器，调整指令顺序充分利用cpu指令流水线）。
    就是每次读取都要到内存中读取，不能重复利用在cache或寄存器中的备份
    
19.const和#define的区别 
    #define仅仅是字符串替换，是在预处理阶段 展开，而const在编译运行阶段使用
    #define仅仅是展开，不分配内存，const分配内存，效率高点（少了读内存的操作）
    const int A* const fun() const  各个const的作用：
    const修饰普通类型变量：变量不可修改
    const修饰指针变量：*左边称为左定向（值不可变），右边称为右定向（地址不可变）。。。左定值，右定向，const修饰不变量！！！
    const修饰类成员函数：防止成员函数修改调用对象的值！！！不能和static一起使用，const成员函数必须具体到某个实例，static修饰静态成员函数，不含this指针，即不能实例化
    
20.堆和栈的区别
    堆不连续高地址扩展，栈连续向低地址扩展（速度快）
    堆由程序员自己申请释放，栈由编译器启动管理
    
21.STL中的map怎么实现的
    内部自建一颗红黑树，这种书具有自动排序功能，所以map内部所有数据都是有序的，key-value一一对应！！！multimap可实现key-values
    效率O(ln(N))
    
22.inline内联函数是否可以递归
    内联函数只是程序员给编译器的一个建议，编译器可以完全忽略。
    当内联函数中出现了复杂的逻辑控制语句，编译器不会在认为他是一个内联函数
    
23.构造函数中是否能抛出异常
    构造函数抛出异常，会导致析构函数不能被调用，对象已分配的内存会被系统释放（可能会造成内存泄漏）。可以跑出但是要保证在抛出之前吧系统资源释放
    不要再析构函数中抛出异常，程序过早结束。。出现不明确行为
    
24.linux中CPU调度怎么做的 
    完全公平调度算法
    策略：
    IO消耗型和处理器消耗型：一般linux更倾向于优先调度IO消耗型进程。
    进程优先级：使用nice值，值越大优先级越低（-19-20）；实时优先级可配置，越高意味着进程优先级越高
    
25.操作系统内存分配与释放 
    连续分配存储管理：单一连续存储，分区式存储（固定分区，动态分区）
    
    
28.程序从源代码文件到运行，全过程是怎么样的，比如分哪些步骤
    预编译（引入头文件，去注释，处理条件编译等），编译（语法语义分析，符号汇总，生成汇编代码），汇编（将汇编代码转化成机器可读的二进制文件），链接（二进制文件链接成为一个可执行的指令重定位）

29.hashset和hashmap的关系
     hashset（存储对象）其实就是用的hashmap（存储键值对，稍快），只不过省略了value，只用了key。hashmap（线程不安全）和hashtable（线程安全）


剑指OFFER，第二遍问题汇总：
1.定义一个空类型，里面什么都没有，sizeof（）多大？为什么？
2.如果在里面加入构造函数和析构函数，sizeof（）多大？为什么？
3.把析构函数标记为虚函数，sizeof()多大？为什么？
4.复制构造函数的参数需要注意？
5.面试题一的赋值运算符函数需要注意哪四点？为什么？
6.赋值运算符函数的异常安全性如何保证？2种方法？
7.c++中定义类型有struct和class，两种有何区别？在c#中呢？
8.c++和从c#中构造函数和析构函数的两大不同点（提示CLR）？
9.实现singleton模式，避免哪两个不好的解法？强烈推荐的（实现按需创建实例）？
10.static关键字特点与好处？
11.数组时间效率高的优点，应用？
12.动态数组扩充容量策略以及需要注意？
13.面试题三，数组中重复的数字？为什么它的时间复杂度是O(n)解释清楚？
14.面试题三扩展，不修改数组找出重复的数字，思路加分析（）？
15.面试题四，二维数组中的查找思路加分析？
16.面试题五，替换空格，思路加分析？
17.归并排序优化？一种重要的思路从后往前！！
18.删除一个链表节点几步？
19.面试题六，从尾到头打印链表？要注意是否可以改变链表结构
20.面试题七，重建二叉树？
21.面试题八，求二叉树的下一个节点？
22.面试题九，用两个栈实现队列？
23.拓展，用两个队列实现栈？
24.二维数组搜索路径，回溯怎么说？什么时候用动态规划？什么时候用贪婪算法？
25.什么是递归什么是循环？优缺点？
26.斐波那契数列的第n项？用时间复杂度O(n)的算法。生僻算法O(logN)
27.斐波那契数列应用，青蛙跳台阶？拓展一下：青蛙依次可以调1，2，3.。。。直到n阶。数学归纳法可以证明f(n) = 2^(n-1)
28.小矩形覆盖大矩形的问题，其实也是斐波那契？
29.4种常见的排序算法说一下？快排写一下？ 
30.队公司员工的年龄进行排序，要求时间复杂度为O(N),空间复杂度O(N).
31.面试题11，求旋转数组的最小数字？
32.面试题12，矩阵中的路径，回溯法？代码要背！！！
33.面试题13，机器人的运动范围？题目描述加代码背诵？
34.面试题14，剪绳子，问题描述，解决？动态规划如何分析？
35.面试题15，二进制中一的个数？三种情况
36.面试题16，数值的整数次方，实现函数double power(double base,int exponent),考虑哪些情况，O(logn)算法
37.面试题17，打印从1到最大的n位数。大数问题如何解决？
38.面试题18，删除链表的节点，O(1)?
39.面试题18二，删除链表中重复的节点？排好序的
40.面试题21，调整数组顺序使得奇数位于偶数前面？如何可拓展？解耦？解释：bool (*func)(int)这个做形参什么意思？实参用该怎么传？
41.面试题22，链表中倒数第k个节点？如何保证代码的鲁棒性？注意哪三个问题
42.面试题23，链表中环的入口节点？？思路
43.面试题24，反转链表？？
44.面试题25，合并两个排序的链表？
45.面试题26，书的子结构？有哪三个函数？
46.面试题27，二叉树的镜像？
47.面试题28，对称的二叉树？
48.面试题29，顺时针打印矩阵？最底层有4种情况，循环终止的条件？
49.面试题30，包含min函数的栈？
50.面试题31，栈的压入/弹出序列？？
    
    
    
    
    
    
    
    
    
  
  
  
  
  
  
  
  
  
  
  
  
